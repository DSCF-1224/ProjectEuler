# file created : 2018.10.28
# file updated : 2018.10.29
# 
# Version 1.0.0 (2018-08-08)
# Base.MainInclude.include( "ProjectEuler/Problem0002/0002_04.jl" )
# 

# Project Euler
# https://projecteuler.net/problem=2
# Problem 0002 [Even Fibonacci numbers]
# Each new term in the Fibonacci sequence is generated by adding the previous two terms.
# By starting with 1 and 2, the first 10 terms will be:
#	1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not exceed four million,
# find the sum of the even-valued terms.

# references
# http://nbviewer.jupyter.org/gist/genkuroki/1ac59bb3e03eac12945d7040d4f98246#%E9%85%8D%E5%88%97%E5%A4%89%E6%95%B0%E3%81%AE%E5%88%9D%E6%9C%9F%E5%8C%96

function FibonacciNum( term::Core.Integer )

	if Base.isequal( term , Base.one( term ) )
		return Base.one( term )
	elseif Base.isequal( term , Base.one( term )*2 )
		return Base.one( term )*2
	else

		# STEP.01
		# make buffer
		buff = Base.Vector{ Core.typeof( term ) }( Core.undef, term )

		# STEP.02
		# store initial condition
		buff[1] = FibonacciNum( Base.one( term )   )
		buff[2] = FibonacciNum( Base.one( term )*2 )

		# STEP.03
		# calculate the target term
		for itr âˆˆ 3:term
			buff[itr] = Base.Checked.checked_add( buff[itr-1] , buff[itr-2] )
		end

		# STEP.END
		return buff[term]

	end
end

function problem0002( upperlimit::Core.Integer )

	# STEP.01
	# initialize the buffer of sum , counter and buffer of Fibonacci numbers
	sum       = Base.zero( upperlimit )
	counter   = Base.one( upperlimit )
	fibonacci = sum

	# STEP.03
	# calculate the target sum
	while Base.isless( fibonacci , upperlimit )

		# STEP.03.01
		# calculate the Fibonacci number
		fibonacci = FibonacciNum( counter )

		# STEP.03.02
		# calculate the target sum
		if Base.iseven( fibonacci )
			sum = Base.Checked.checked_add( sum, fibonacci )
		end

		# STEP.03.03
		# update the counter
		counter = Base.Checked.checked_add( counter, Base.one( upperlimit ) )
		
	end

	# STEP.END
	return sum
end

# upperlimit_target = 4*10^6
# 0.018904 seconds (52.93 k allocations: 2.820 MiB)
# elapsed time (ns): 18904116
# bytes allocated:   2956635
# pool allocs:       52932

# upperlimit_target = 4*10^7
# 0.018720 seconds (52.94 k allocations: 2.822 MiB)
# elapsed time (ns): 18719536
# bytes allocated:   2958939
# pool allocs:       52938

# upperlimit_target = 4*10^8
# 0.018764 seconds (52.94 k allocations: 2.823 MiB)
# elapsed time (ns): 18764058
# bytes allocated:   2960331
# pool allocs:       52941

# upperlimit_target = 4*10^9
# 0.018719 seconds (52.95 k allocations: 2.826 MiB)
# elapsed time (ns): 18719227
# bytes allocated:   2962763
# pool allocs:       52946

# upperlimit_target = 4*10^10
# 0.018740 seconds (52.95 k allocations: 2.828 MiB)
# elapsed time (ns): 18739633
# bytes allocated:   2965275
# pool allocs:       52950

upperlimit_target = Base.GMP.BigInt( 10 )^150
Base.@timev Base.Printf.@printf( Base.stdout , "%d\n" , problem0002( upperlimit_target ) )